#### 安装

1. 解压安装包

   - 各种依赖：

   - gcc升级：因redis 5.0以后对gcc有版本要求，centOS7.6的gcc默认版本4.8.5不符合。

     ```
     yum -y install centos-release-scl
     yum -y install devtoolset-9-gcc devtoolset-9-gcc-c++ devtoolset-9-binutils
     echo "source /opt/rh/devtoolset-9/enable" >> /etc/profile
     source /etc/profile
     gcc -v
     ```

2. 进入到redis目录下的src，执行make

3. 默认安装 or 指定目录安装

   - 默认安装： 直接在解压目录下执行make install
   - (不建议)指定目录安装  make  PREFIX="指定的目录"  install，指定目录安装完成之后，需手动创建软链接 

4. 设置后台启动

   - 修改文件redis.conf 中的 daemonize 的no 为yes
   - 使用命令   redis-server  /redis.conf的目录/redis.conf



#### 基础概念

1. 数据类型:   string、list、set、zset(sorted set --有序集合)、hash哈希

2. 操作:   push、pop、add、remove、交集、并集、差集

3. 原子性:  因为7之前都是单线程，所以操作都是由一个线程去处理，不存在线程调度导致的操作不完整。

   - 例如：用户积分当前为100，不可能存在多个线程同时去对用户积分进行以100为当前积分的加减操作。

4. 单线程+IO多路复用

5. String类型（二进制安全），即：只要图片、序列化对象能转换为string,就都可以存。

6. String 内存扩容，一般为小于1M的字符串成倍扩容，大于则仅扩容1M，字符串最大512M。

7. LIst 类型，底层为双向链表，特点：头尾操作性能高，索引操作中间性能低。

   - 重点注意： 取值的方向 和 键的消亡（值被lpop/rpop取完）。

   - 列表从左侧不断推入新的数据后，最先推入的数据的位置会不断右移，

     所以删除的时候，需要格外注意从左边或右边删。

8. List 底层在列表size较小时，会压缩成ziplist进行存储，当size较大时，则会将数据分开存储在多个ziplist中

   通过双向指针拼接为一个quicklist。

9. Set 无序集合，数据结构为字典，底层为hash表，查询操作时间不会随着数据量增大而增大。

   - 集合中的每个值为 hash

10. Hash  键值对集合，实际的数据 也可以理解为   key    value(field,value)。

11. Hash  数据结构：ziplist、hashtable，原理类似List。

12. Zset 有序集合，集合中的每个元素都关联了一个score(评分)，元素唯一(不重复),score可重复。

13. Bitmaps  位操作数据类型。

    - bitmaps 用来1来标记用户行为，比set 存储用户行为更加节省空间，所以bitmaps优势在于节约空间资源。

14. HyperLogLog  

    - 基数： {1,4,8,5,9,6,2,5,4} 集合去重后得到的{1,2,4,5,6,8,9}就叫做基数集合,此时基数为7。

    - 统计基数时占用空间更小。
    - 应用场景：统计当日独立访问用户，即：有多少个用户访问过网站，同一用户当天访问多次也记录为一个独立用户。同时在电商领域，也可以统计一个时间周期内，有多少个用户下过单。

15. gregraphic

    - 用于地理信息和设置查询，范围查询

16. 发布与订阅

    - 发布者发布消息到频道，订阅者在频道订阅消息。

      订阅命令： SUBSCRIBE channel1

      发消息命令：publish channel1 hello

      - channel1 为自定义的频道

      ```
      SUBSCRIBE channel1
      publish channel1 hello
      ```

17. RedisTemplate 存储知识点：

    - 使用opsfor*等相关方法，将代码传入的数据进行序列化后存入redis。

18. Redis 的自动序列化需要自定义序列化配置类，且存储对象数据的时候会多存一个类型值，占用空间多；

    手动序列化反之占用空间小，但每次需要手动对队形做序列化和反序列化处理。

19. 程序使用缓存的一般流程： 
    - 查询缓存
    - 查询成功则直接返回，否则查询数据库
    - 查询数据库成功则写数据到redis并返回正确结果，否则返回错误信息

20. redis 缓存更新策略：

    1. 内存淘汰策略：内存不足时，删除部分缓存

    2. 定时更新策略：给缓存设定有效期，过期自动删除

    3. 主动更新策略：缓存调用者手动更新缓存

       - 缓存调用者手动操作缓存（靠谱）

         - 更新、删除：正常情况应该尽量避免过多的无效写缓存，在需要查询缓存的时候，将旧缓存删除，更新为新缓存

         - 数据库和缓存的一致性：<font color="red">**事务和分布式事务**</font>

         - "删缓存"and"改数据库":  不同线程在操作同一缓存时如果未加锁可能导致缓存数据和数据库数据不一致；

           如果加锁不当，可能导致死锁？

       - 缓存和数据库作为一个整体服务 （维护可能比较麻烦）

       - 缓存调用者仅读写缓存，由其他线程异步操作将缓存数据持久化到数据库（缓存更新时，异步线程还没有启动的话就会

         导致数据不一致）。

       - <font color= "red">缓存一致性</font>： 需要根据一致性要求的高低，选择不同的策略。
         同时，高一致性时，读操作可优先查缓存，未命中时则查数据库并重新写入缓存。

         ​                                   写操作为保证一致性最好先写数据库，再删除并更新缓存。

21. 缓存的穿透、雪崩、击穿

    - 穿透： redis、mysql中都不存在数据

      - 解决方案：通过给对应的key设置null值，保证同样的恶意请求，下次直接访问缓存并直接返回错误。

    - 雪崩：同一时刻大量热key或key失效，或redis宕机，导致大量请求直接到达数据库。

      - 解决方案：
        1. 不同key的有效时间设置随机数
        2. redis 集群模式保证高可用
        3. 缓存业务添加降级限流策略（即：一旦发生redis异常，直接从redis上游进行限流【 Spring Cloud 】 ，避免大量请求直接访问数据库）
        4. 给业务添加多级缓存（nginx缓存、redis缓存、数据库缓存等）

    - 击穿：热点key的突然失效【即：高并发访问的key突然失效】，同时缓存重写的业务逻辑较为复杂，导致段时间内的大量访问直接访问数据库。

      - 现象：key刚好失效，大量请求直接访问数据库并执行缓存重建的步骤，
          		1. 大量请求同时访问数据库（数据库压力陡增） 
          		2. n个线程同时重写缓存，<font color="red">服务器的压力会不会陡增呢？</font>

      - 解决方案： 

        1. 互斥锁：线程查询未命中缓存后，先获取互斥锁，拿到锁之后再进行写缓存的操作，后续其他线程肯定是无法正常获取锁的。如果等待一个单位时间后，再次查询缓存是否命中，如果依旧未命中，则继续取锁/休眠，直至命中缓存为止。

           - 实现流程：

             1. 执行查询

             2. 判断是否命中缓存
                1. 命中则直接返回数据
                2. 未命中则尝试获取互斥锁
                   1. 获取失败，则休眠1个单位时间后再次执行查询
                   2. 获取成功
                      1. 查询数据库
                      2. 重写缓存
                      3. 释放互斥锁
                      4. 返回数据

           

        2. 逻辑过期：直接在缓存的键值对添加过期时间（即：不通过redis的TTL设置过期时间，而是通过对应的服务获取redis键对应的值中的过期时间字段来手动判断是否过期）。

           则先开始获取锁，如果获取成功，则开启一个新的线程进行缓存重写的操作，同时由当前线程直接将过期的缓存数据返回；如果获取锁失败，则说明已经有线程正在重写缓存，当前线程则只需要直接返回过期的缓存数据。

           - 实现流程：
             1. 执行查询
             2. 判断是否命中缓存
                1. 未命中则直接返回空（对于热key未命中，可能是当前key对应的业务并不是重要）
                2. 命中则需要提取对应的过期时间判断键是否过期
                   1. 如果没有过期，则直接返回数据
                   2. 如果过期，则尝试获取互斥锁
                      1. 获取锁成功(同时再次确认缓存是否过期，即：做二次确认)
                         - 返回数据
                         - 重写缓存（新数据、新的过期时间）
                         - 释放互斥锁
                      2. 获取失败，则直接返回旧数据

      - 优缺点：
        互斥锁：

        优点： 1. 无额外内存消耗 2. 一致性有保证 3. 实现简单

        缺点： 1. 死锁风险 2. 性能影响

        逻辑过期：
        优点： 1. 性能较互斥锁更好
        缺点： 1. 一致性无法保证  2. 额外的内存消耗（新开一个专门写缓存的线程）3. 实现相较互斥锁复杂

      - 总结：具体使用那种解决方案需要基于实际的业务考虑。

        

        

        

#### 常用命令操作

1. key

   - 查询所有键名：keys *
   - 判断key是否存在：exists key    返回1代表存在
   - 查看键类型： type key  
   - 删除： del key
   - 设置过期时间： expire key time    time单位为秒
   - 查看键的数量： dbsize
   - 清空当前库：flushdb
   - 清空所有：flushall

2. string

   - 设置字符串： set key1 StringValue1
   - 获取字符串： get key1
   - 追加字符串： append key1 appendValue
   - 获取键长度：strlen key1
   - 不存在时设置值： setnx key value
   - 对应值累加 value：incr key value
   - 对应值累减 value：decr key value
   - 多个键值设置/获取： mset k1 v1 k2 v2 ...    /   get k1 k2 k3
   - 获取key对应值(范围内的值）:  getrange k1  索引开始位置   索引结束位置
     - 例如： 值为abcd ，getrange key 0 2 ,结果为abc

   - 同时设置键值及过期时间：setex key time(过期时间)  value(值)
   - 获取过期时间：ttl key

3. List

   - 从列表 左侧/右侧 添加值： lpush / rpush 

   - 从左侧按照索引下标获取元素： lrange key start_index  end_index

     - 实际上获取的值 是从右侧向左按顺序取值

   - 从列表 左侧/右侧 获取值： lpop / rpop  

   - 从列表右边取值直接插入到列表左边： rpoplpush  key1 key2

     - 把key1右边的值推出来插入到key2的左侧

   - 获取列表长度：llen key

   - 在指定值(value)后插入对应的值(newvalue)： linsert key before value newvalue

   - 从左侧数删除n个匹配到的value值:  lrem key n[n个]  value值

     - 当前key的值为:  3，4，5，6，3，4，5，7，3

       执行lrem key  2  3，执行后查看对应key的值为：4 5 6 4 5 7 3

   - 替换操作： lset key index value

4. Set

   - 添加值： sadd key value1 value2 ...
   - 获取集合所有值： smember key
   - 判断key 是否包含指定值： sismember key value
   - 返回集合中的元素个数： scard key
   - 删除集合中的指定元素：srem key value1 value2 ...
   - 随机推出一个值： spop key
   - 随机获取n个值： srandmember key n
   - 把集合中的一个值移动到另一个集合： smove source destination value
   - 返回两个集合的交集：sinter key1 key2
   - 返回连个结合的并集： sunion key1 key2
   - 返回两个集合的差集：  sdiff key1 key2    或  sdiff key2 key1

5. Hash

   - 添加值： hset key field value field2 value2
   - 获取值：hget key field
   - 批量添加值： hmset key field value  field value
     - 在4.0版本之前每次只能添加一个field，在4.0之后hset 和 hmset表面上没有区别。

   - 判断key中的field是否存在：hexists key field
   - 列出key中所有的field： hkeys
   - 列出key中所有的value： hvals

6. Zset

   - 添加： zadd key score value
   - 获取：zrange key start_index end_index
   - 获取（返回结果带评分）： zrange key  start_index end_index withscores
   - 获取（请求带评分范围，返回结果从小到大):  zrange key  min max
   - 获取（请求带评分范围，返回结果从大到小):  zrevrangebyscore key max min
   - 删除： zrem key value
   - 统计： zcount key min max
   - 获取排名：zrank key value
   - 加分： zincrby key increament value

7. Bitmaps

   - 设置： setbit key offset value
   - 获取指定位置上的值： getbit key offset
   - 获取指定key的值为1的数量： bitcount key
   - 交、并、差集操作：bittop？？？   待验证

8. HyperLogLog

   - 添加：pfadd key value
   - 获取基数: pfaccount key
   - 合并：pfmerge new_key  source_key1 source_key2

9. gregraphic

   - 添加： geoadd  key (国家:城市)  经纬度  目标城市
     - 如： geoadd china:city  120.52 30.40 shanghai

   - 获取经纬度：geopos china:city beijing
   - 获取两地间距：geodist key (国家:城市) 目标城市1 目标城市2  长度单位(m km)
   - 获取半径内目标： geodius key (国家:城市)  精度 纬度  半径(m | km)   m/km

#### 配置文件

-  [ Units ] 定义了基本的度量单位
-  [ INCLUDE ]   引入其他的配置文件？（有待验证）   
-  [ NETWORK ]  bind 限定访问地址

   - 打开远程访问： 1. 将bind 注释  2. protected-mode 由 yes 改为 no
   - 默认端口号： port 6379
   - 默认的backlog总数(完成三次握手的队列和未完成三次握手的队列)：tcp-backlog  511
     -  linux 系统默认值 128，高并发场景需要增大这个值。
     -  设置路径：/proc/sys/net/core/somaxconn 和 /proc/sys/net/ipv4/tcp_max_syn_backlog

   - 超时时间(设置为0表示永不超时)： timeout 0
   - 心跳检查时间：tcp-keepalive 300（此处代表超过300秒没有任何操作就释放链接）
-  [ GEMERAL ]

   - 允许后台启动：demonize  yes
   - 指定pid 存储位置： pidfile  /目标路径/redis_63779.pid
   - 日志级别设置（默认notice）：loglevel  debug/verbose/notice/warning  
-  [ SECURITY ]

   -   如何在配置文件中设置redis密码？？？？
-  [CLIENTS]
   - 最大连接数：maxclient 
-  [ maxmemory ]
   - 必须设置上限，否则机器会宕机
   - 设置内存后，redis内存满之后会根据maxmemory-policy 中的策略配置删除一定量的key。



#### 基础代码

1. 创建链接池

   ```java
   public class JedisConnectionFactory {
       //创建链接池，并在静态代码块中初始化，其他java通过getJedis获取链接，
       //这个链接就是从jedis链接池中取到的。
       private static final JedisPool jedisPool;
   	
       static {
           JedisPoolConfig poolConfig = new JedisPoolConfig();
           poolConfig.setMaxTotal(8);
           poolConfig.setMaxIdle(8);
           poolConfig.setMinIdle(0);
           jedisPool =  new JedisPool(poolConfig,"121.5.27.27",6379,1000,"Ma_852456_");
       }
   
       public static Jedis getJedis(){
           return jedisPool.getResource();
       }
   
   }
   ```

1. SpringDataRedis：

   - 操作步骤：

     1. 安装依赖

        ```xml
                <dependency>
                    <groupId>org.springframework.boot</groupId>
                    <artifactId>spring-boot-starter-data-redis</artifactId>
                </dependency>
                <!-- redis 链接池依赖 -->
                <dependency>
                    <groupId>org.apache.commons</groupId>
                    <artifactId>commons-pool2</artifactId>
                </dependency>
        ```

     2. 配置redis信息

        ```yaml
        spring:
          redis:
            host: 121.5.27.27
            port: 6379
            password: Ma_852456_
            #client-type: jedis
            lettuce:
              pool:
                max-active: 8
                max-wait: 1000ms
                max-idle: 8
                min-idle: 0
        ```

     3. 注入RedisTemplate

        ```java
        package com.fan.heima;
        
        
        import org.junit.jupiter.api.Test;
        import org.springframework.beans.factory.annotation.Autowired;
        import org.springframework.boot.test.context.SpringBootTest;
        import org.springframework.data.redis.core.RedisTemplate;
        import javax.annotation.Resource;
        
        //通过SpringDataRedis操作redis,使用opsForValue()可以操作字符串数据对象
        //其他相应的有：opsForHash、opsForList、opsForSet、opsForSet、opsForZset.
        
        @SpringBootTest
        public class SpringDataRedisTest {
        
            @Resource
            private RedisTemplate redisTemplate;
        
            @Test
            void testString() {
                // 使用Template 写入数据
                redisTemplate.opsForValue().set("code_type","spring_data_redis_template");
                // 获取数据
                Object code_type =  redisTemplate.opsForValue().get("code_type");
                System.out.println("当前使用的代码为： " +code_type);
            }
            
        }
        ```

     4. 手动序列化和手动反序列化

        ```java
                //1. create Object
                User user = new User("赵七",17);
                //2. manual serialization
                String json = mapper.writeValueAsString(user);
                //3. wirte data
                stringRedisTemplate.opsForValue().set("user:zhaoqi",json);
        
                //1. get json String from redis
                String str_manual_user = 	   stringRedisTemplate.opsForValue().get("user:zhaoqi");
                //2. manual deserialization
                User manual_user = mapper.readValue(str_manual_user,User.class);
                System.out.println(manual_user);
        ```

     5. 获取、释放锁的一种实现方式

        ```shell
        # 通过在线程中读取指定键的值确定锁定状态，同时最好给锁添加一个有效期，以避免死锁。
        # 设定一个键的值作为锁定标记
        setnx lock locked
        # 删除键 作为 释放标记
        del lock
        ```

        ```java
        // java 客户端设置setnx的API,unit为时间单位：TimeUnit.MINUTES
        // 获取🔒
        private boolean tryLock(String key){
        Boolean flag = stringRedisTemplate.opsForValue().setIfAbsent(key,value,timeout,unit);  
          	//BooleanUtil.isTrue(flag);  这里使用的hutool的方法，避免自动拆箱导致的nullpoint
          return BooleanUtil.isTrue(flag);
        }
        // 释放🔒
        stringRedisTemplate.opsForValue().delete(key);
        ```

     6.  比较重要的几种类型转换

        ```java
        //比较重要的几种转换，字符串转json，json转对象（反序列化）【使用hutool】
        // 使用JSONUtil.toBean((强转类型)Object，类名.class) 时，由于Object的代码设计算，这里可能需要强转
        ```

     7. 

     - 问题记录：

     ```java
     // 这里最初使用Autowired 提示找不到对象无法注入，所以改用了Resource,
     // 需要重点查询一下Autowired 、 Resource 的不同？
         @Resource
         private RedisTemplate redisTemplate;
     ```

     ​			

   

#### 额外的知识点：

1. 缓存： 浏览器缓存、 应用层缓存、数据库缓存（cpu缓存、磁盘缓存）







#### 问题：

1. list 底层使用双向指针串起来，这个需要仔细再思考一下？双向指针 and 指针在内存中的存储方式再想想。
2. 如何在配置文件中设置redis密码？？？？
3. redis 的发布和订阅   与 消息队列（kafka、rabbitmq）的区别？redis的发布、订阅的应用场景？
4. Bitmaps 待验证练习
5. 额外知识点：ThreadLocal的实现原理？
6. 利用逻辑过期解决缓存击穿的代码实现需要重点模拟？

7. redis穿透本身可以理解为大量的恶意请求不存在的缓存，应该算是一个安全问题了，
   性能测试工程师有必要验证，缓存穿透在不同量级上对数据库，整个系统的影响吗？

#### 相关英文：

- mutex： 互斥
- expire： 过期





 
